const fetch = require('node-fetch');
const fs = require('fs');
const path = require('path');
const { downloadVideo, extractAutoGeneratedCaptions, uploadVideo } = require('@helpers');
const { editVideo, getAllTextTracks, getVideo } = require('@services')?.videosServices;
const { handleLogPush, saveFileLocally } = require('@utils');

const getAutoGeneratedCaptionsFile = async (req, res) => {

    const failures = [], successes = [];

    try {

        const { body: { videos }, query: { fields } } = req;

        for (const video of videos) {

            console.log(`\nIterating over video ${video}...`);

            const textTracks = await getAllTextTracks(video, fields);

            if (!textTracks.ok) {

                const { ok, ...errorInfo } = textTracks;

                failures.push({ ...errorInfo, video });

                continue;

            };

            const autoGeneratedCaptions = extractAutoGeneratedCaptions(textTracks.data);

            if (!autoGeneratedCaptions.ok) {

                const { ok, ...errorInfo } = autoGeneratedCaptions;

                failures.push({ ...errorInfo, video });

                continue;

            };

            const { link } = autoGeneratedCaptions.data;

            const response = await fetch(link); // Get the auto-generated captions .vtt file.

            if (!response.ok) {

                const errorInfo = {
                    statusCode: response.status,
                    message: 'Failed to retrieve the auto-generated captions file.',
                    video
                };

                failures.push(errorInfo);

                continue;

            };

            const autoGeneratedCaptionsContent = await response.text();

            const folderPath = path.join(__dirname, '../', 'downloads', 'captions');

            const fileName = `${video}.vtt`;

            const autoGeneratedCaptionsSave = await saveFileLocally(folderPath, fileName, autoGeneratedCaptionsContent);

            if (!autoGeneratedCaptionsSave.ok) {

                const { ok, ...errorInfo } = autoGeneratedCaptionsSave;

                failures.push({ ...errorInfo, video });

                continue;

            };

            console.log(`\nAuto-generated captions file of video ${video} successfully saved locally.`);

            successes.push(video);

        };

        const total = {
            videos: videos.length,
            successes: successes.length,
            failures: failures.length
        };

        console.log('\n', total, '\n');

        res.status(200).json({ total, data: { successes, failures } });

    } catch (error) {

        console.error('\n', error, '\n');

        res.status(500).json({ message: error.message });

    };

}; //!GETAUTOGENERATEDCAPTIONSFILE-END

const reuploadVideos = async (req, res) => {

    const logs = [], uploads = [];

    try {

        const { videos } = req.body;

        for (const id of videos) {

            console.log(`\nIterating over video ${id}...`);

            const videoDownload = await downloadVideo(id);

            if (!videoDownload.ok) {

                handleLogPush(logs, videoDownload);

                continue;

            };

            console.log('\nVideo downloaded successfully.');

            const downloadedVideo = videoDownload.data;

            const fileSize = fs.statSync(downloadedVideo.file.path)?.size;

            const destinationFolder = '/me/projects/19825089'; //! Obtener dinÃ¡micamente (`body` o `params`, por ejemplo).

            const uploadApproach = { approach: 'tus', size: fileSize }; // The `upload.size` field is required for the resumable ('tus') approach. 

            const videoUpload = await uploadVideo(downloadedVideo, destinationFolder, uploadApproach);

            if (!videoUpload.ok) {

                handleLogPush(logs, videoDownload);

                continue;

            }

            console.log(`\nVideo ${id} has been successfully reuploaded to URI: ${destinationFolder}`);

            // Remove the downloaded video file from the local directory.
            await fs.promises.unlink(downloadedVideo.file.path);

            uploads.push(id);

        };

        res.status(200).json({
            message: `Reupload process completed for ${uploads.length} out of ${videos.length} videos.`,
            data: { uploads, logs }
        });

    } catch (error) {

        console.error('\n', error, '\n');

        const statusCode = error.statusCode ?? 500;

        res.status(statusCode).json({ message: error.message });

    };

}; //!REUPLOADVIDEOS-END

const editEmbedDomains = async (req, res) => {

    const edited = [], logs = [];

    try {

        const { videos, domains } = req.body;

        const { action } = res.locals;

        for (const id of videos) {

            console.log(`\nIterating over video ${id}...`);

            let data = {};

            if (action === 'embed_domains_delete') {

                //TODO: Step 1 - Check video embed privacy settings.
                const FIELDS = 'privacy.embed';

                const video = await getVideo(id, FIELDS);

                if (!video.ok) {

                    handleLogPush(logs, video);

                    continue;

                }

                //TODO: Step 1.1 - Update video embed privacy settings if `privacy.embed` is not 'whitelist'. Required to edit embed domains list.
                const { privacy } = video.data;

                if (privacy.embed !== 'whitelist') {

                    console.log('\nUpdating embed privacy settings...');

                    data = { privacy: { embed: 'whitelist' } };

                    const embedPrivacyEdit = await editVideo(id, data, FIELDS);

                    if (!embedPrivacyEdit.ok) {

                        handleLogPush(logs, embedPrivacyEdit);

                        continue;

                    }

                }

                //TODO: Step 2 - Update (delete) video embed domains list.
                data = { [action]: domains };

                const domainsListEdit = await editVideo(id, data);

                if (!domainsListEdit.ok) {

                    handleLogPush(logs, domainsListEdit);

                    continue;

                }

                console.log(`\n[Video: ${id}] Embed domains list updated successfully.`);

                edited.push(id);

            } else {

                //TODO: Update (overwrite or add) video embed domains list and embed privacy settings if necessary.
                data = {
                    privacy: { embed: 'whitelist' }, // Required to edit embed domains list.
                    [action]: domains
                };

                const embedSettingsEdit = await editVideo(id, data);

                if (!embedSettingsEdit.ok) {

                    handleLogPush(logs, embedSettingsEdit);

                    continue;

                }

                console.log(`\n[Video: ${id}] Embed domains list updated successfully.`);

                edited.push(id);

            };

        };

        // The array is empty
        if (!edited.length) {

            throw new Error('All attempts failed.');

        }

        res.status(200).json({
            message: `Embed domains list updated for ${edited.length} out of ${videos.length} videos.`,
            data: { edited, logs }
        });

    } catch (error) {

        console.error(error);

        const statusCode = error.cause?.statusCode ?? error.statusCode ?? 500;

        res.status(statusCode).json({ message: error.message, logs });

    };

}; //!EDITEMBEDDOMAINS-END

module.exports = {
    editEmbedDomains,
    getAutoGeneratedCaptionsFile,
    reuploadVideos
};
